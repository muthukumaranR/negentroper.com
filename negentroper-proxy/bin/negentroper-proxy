#!/usr/bin/env node

const { Command } = require('commander');
const path = require('path');
const fs = require('fs-extra');
const axios = require('axios');

const program = new Command();

program
  .name('negentroper-proxy')
  .description('CLI for Negentroper Proxy System')
  .version('1.0.0');

// Global options
program
  .option('-c, --config <path>', 'Config file path', '.env')
  .option('-v, --verbose', 'Verbose output')
  .option('--api-url <url>', 'API base URL', 'http://localhost:3000/api')
  .option('--api-key <key>', 'API key for admin operations');

// Load environment config
function loadConfig(configPath) {
  require('dotenv').config({ path: configPath });
}

// Get API client
function getApiClient(options) {
  const baseURL = options.apiUrl || process.env.API_URL || 'http://localhost:3000/api';
  const apiKey = options.apiKey || process.env.ADMIN_API_KEY;

  return axios.create({
    baseURL,
    headers: apiKey ? { 'X-API-Key': apiKey } : {},
    timeout: 10000
  });
}

// Start command
program
  .command('start')
  .description('Start the proxy server')
  .option('-d, --daemon', 'Run as daemon')
  .option('-p, --port <port>', 'HTTP port', '80')
  .option('--https-port <port>', 'HTTPS port', '443')
  .action(async (options) => {
    loadConfig(program.opts().config);
    
    if (options.daemon) {
      console.log('Starting proxy server as daemon...');
      // In production, you might use pm2 or similar
      const { spawn } = require('child_process');
      const child = spawn('node', [path.join(__dirname, '../src/index.js')], {
        detached: true,
        stdio: 'ignore'
      });
      child.unref();
      console.log(`Proxy server started with PID: ${child.pid}`);
    } else {
      console.log('Starting proxy server...');
      require('../src/index.js');
    }
  });

// Stop command
program
  .command('stop')
  .description('Stop the proxy server')
  .action(async () => {
    try {
      // Try to gracefully stop via API
      const client = getApiClient(program.opts());
      await client.post('/admin/shutdown');
      console.log('Proxy server stopped gracefully');
    } catch (error) {
      console.log('Could not contact proxy server, it may already be stopped');
    }
  });

// Status command
program
  .command('status')
  .description('Show proxy system status')
  .action(async () => {
    try {
      const client = getApiClient(program.opts());
      const response = await client.get('/health');
      
      console.log('\n=== Negentroper Proxy Status ===');
      console.log(`Status: ${response.data.status}`);
      console.log(`Uptime: ${Math.floor(response.data.proxy.uptime / 60)} minutes`);
      console.log(`Projects: ${response.data.projects.total} (${response.data.projects.healthy} healthy)`);
      console.log(`Memory: ${Math.round(response.data.proxy.memory.heapUsed / 1024 / 1024)}MB used`);
      
    } catch (error) {
      console.error('Failed to get status:', error.message);
    }
  });

// Project management commands
const projects = program
  .command('projects')
  .description('Manage projects');

projects
  .command('list')
  .description('List all projects')
  .option('-t, --type <type>', 'Filter by type')
  .option('-s, --status <status>', 'Filter by status')
  .action(async (options) => {
    try {
      const client = getApiClient(program.opts());
      const params = {};
      if (options.type) params.type = options.type;
      if (options.status) params.status = options.status;
      
      const response = await client.get('/projects', { params });
      
      console.log(`\n=== Projects (${response.data.total}) ===`);
      response.data.projects.forEach(project => {
        const healthIcon = project.health.status === 'healthy' ? '✅' : '❌';
        console.log(`${healthIcon} ${project.subdomain}.negentroper.com -> :${project.port} (${project.type})`);
        if (program.opts().verbose) {
          console.log(`    Description: ${project.description || 'No description'}`);
          console.log(`    Status: ${project.status}`);
          console.log(`    Tags: ${project.tags?.join(', ') || 'None'}`);
        }
      });
      
    } catch (error) {
      console.error('Failed to list projects:', error.message);
    }
  });

projects
  .command('add <name> <subdomain> <port>')
  .description('Add a new project')
  .option('-t, --type <type>', 'Project type', 'web')
  .option('-d, --description <desc>', 'Project description')
  .option('--health-path <path>', 'Health check path', '/')
  .option('--ssl', 'Enable SSL')
  .option('--auto-start', 'Auto-start on boot')
  .option('--tags <tags>', 'Comma-separated tags')
  .action(async (name, subdomain, port, options) => {
    try {
      const client = getApiClient(program.opts());
      
      const projectData = {
        name,
        subdomain,
        port: parseInt(port),
        type: options.type,
        description: options.description,
        healthCheckPath: options.healthPath,
        ssl: options.ssl || false,
        autoStart: options.autoStart || false,
        tags: options.tags ? options.tags.split(',').map(t => t.trim()) : []
      };
      
      const response = await client.post('/admin/projects', projectData);
      console.log(`✅ Project registered: ${subdomain}.negentroper.com -> :${port}`);
      
    } catch (error) {
      console.error('Failed to add project:', error.response?.data?.message || error.message);
    }
  });

projects
  .command('remove <subdomain>')
  .description('Remove a project')
  .action(async (subdomain) => {
    try {
      const client = getApiClient(program.opts());
      await client.delete(`/admin/projects/${subdomain}`);
      console.log(`✅ Project removed: ${subdomain}`);
      
    } catch (error) {
      console.error('Failed to remove project:', error.response?.data?.message || error.message);
    }
  });

projects
  .command('health <subdomain>')
  .description('Check project health')
  .action(async (subdomain) => {
    try {
      const client = getApiClient(program.opts());
      const response = await client.get(`/projects/${subdomain}/health`);
      
      const project = response.data.project;
      const current = response.data.current;
      const uptime = response.data.uptime;
      
      console.log(`\n=== Health Check: ${project.subdomain} ===`);
      console.log(`Status: ${current.healthy ? '✅ Healthy' : '❌ Unhealthy'}`);
      console.log(`Response Time: ${current.responseTime}ms`);
      console.log(`HTTP Status: ${current.status}`);
      console.log(`Uptime (24h): ${uptime.uptime}%`);
      console.log(`Total Checks: ${uptime.totalChecks}`);
      
    } catch (error) {
      console.error('Failed to check health:', error.response?.data?.message || error.message);
    }
  });

// Discovery commands
const discovery = program
  .command('discovery')
  .description('Auto-discovery operations');

discovery
  .command('scan')
  .description('Scan for running services')
  .action(async () => {
    try {
      const client = getApiClient(program.opts());
      console.log('Starting discovery scan...');
      
      const response = await client.get('/discovery/scan');
      
      console.log('✅ Discovery scan completed');
      console.log(`Active Services: ${response.data.results.activeServices}`);
      console.log(`Web Services: ${response.data.results.webServices}`);
      console.log(`Duration: ${response.data.results.duration}ms`);
      
    } catch (error) {
      console.error('Discovery scan failed:', error.message);
    }
  });

// SSL commands
const ssl = program
  .command('ssl')
  .description('SSL certificate management');

ssl
  .command('generate')
  .description('Generate SSL certificates')
  .option('--staging', 'Use staging environment')
  .action(async (options) => {
    try {
      console.log('SSL certificate generation...');
      console.log('Note: This requires manual DNS configuration for wildcard certificates');
      console.log('See documentation for complete setup instructions');
      
    } catch (error) {
      console.error('SSL generation failed:', error.message);
    }
  });

ssl
  .command('info')
  .description('Show SSL certificate information')
  .action(async () => {
    try {
      console.log('SSL certificate information...');
      console.log('Note: SSL info endpoint not yet implemented');
      
    } catch (error) {
      console.error('Failed to get SSL info:', error.message);
    }
  });

// Quick setup command
program
  .command('setup')
  .description('Quick setup wizard')
  .action(async () => {
    const inquirer = require('inquirer');
    
    console.log('\n=== Negentroper Proxy Setup ===\n');
    
    const answers = await inquirer.prompt([
      {
        type: 'input',
        name: 'domain',
        message: 'Base domain:',
        default: 'negentroper.com'
      },
      {
        type: 'input',
        name: 'email',
        message: 'Email for SSL certificates:'
      },
      {
        type: 'confirm',
        name: 'autoDiscovery',
        message: 'Enable auto-discovery?',
        default: true
      },
      {
        type: 'confirm',
        name: 'ssl',
        message: 'Generate SSL certificates?',
        default: false
      }
    ]);
    
    // Generate .env file
    const envContent = `
# Negentroper Proxy Configuration
NODE_ENV=development
PORT=80
HTTPS_PORT=443

# Domain Configuration
BASE_DOMAIN=${answers.domain}
WILDCARD_DOMAIN=*.${answers.domain}

# SSL Configuration
SSL_EMAIL=${answers.email || 'admin@' + answers.domain}
SSL_AUTO_RENEW=true
SSL_STAGING=true

# Discovery Configuration
AUTO_DISCOVERY=${answers.autoDiscovery}
DISCOVERY_INTERVAL=30000

# Admin Configuration
ADMIN_API_KEY=${Math.random().toString(36).substring(2, 15)}
ENABLE_ADMIN_UI=true
`.trim();

    await fs.writeFile('.env', envContent);
    console.log('\n✅ Configuration saved to .env');
    console.log('✅ Setup completed!');
    console.log('\nNext steps:');
    console.log('1. npm install');
    console.log('2. negentroper-proxy start');
    console.log('3. Configure DNS to point *.negentroper.com to this server');
  });

// Parse arguments
program.parse();